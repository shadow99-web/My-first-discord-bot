const { SlashCommandBuilder, AttachmentBuilder } = require("discord.js");
const discordTranscripts = require("discord-html-transcripts");
const fs = require("fs-extra");
const axios = require("axios");
const FormData = require("form-data");
const path = require("path");

module.exports = {
  name: "transcriptchat",
  description: "Generate and upload a transcript of this or another channel.",
  usage: "/transcriptchat [#channel] [images yes|no]",

  data: new SlashCommandBuilder()
    .setName("transcriptchat")
    .setDescription("Generate an HTML transcript of a channel.")
    .addChannelOption(option =>
      option.setName("channel")
        .setDescription("Choose channel to generate transcript for.")
        .setRequired(false)
    )
    .addStringOption(option =>
      option.setName("images")
        .setDescription("Include images? (yes/no)")
        .setRequired(false)
        .addChoices(
          { name: "Yes (Include Images)", value: "yes" },
          { name: "No (Faster)", value: "no" }
        )
    ),

  async execute(interactionOrMessage, client) {
    try {
      // Detect type
      const isSlash =
        interactionOrMessage?.isChatInputCommand?.() ||
        !!interactionOrMessage?.commandName;
      const interaction = isSlash ? interactionOrMessage : null;
      const message = isSlash ? null : interactionOrMessage;

      const user = isSlash ? interaction.user : message?.author;
      const guild = isSlash ? interaction.guild : message?.guild;

      // --- Get channel ---
      let channel;
      if (isSlash && interaction.options) {
        channel =
          interaction.options.getChannel("channel") ||
          interaction.channel ||
          guild?.channels?.cache?.get(interaction.channelId);
      } else {
        channel =
          message?.mentions?.channels?.first() ||
          message?.channel ||
          guild?.channels?.cache?.get(message?.channelId);
      }

      if (!channel || !channel.isTextBased?.()) {
        const msg = "‚ùå That channel isn‚Äôt text-based or couldn‚Äôt be found.";
        return isSlash
          ? interaction.reply({ content: msg, ephemeral: true })
          : message.reply(msg);
      }

      const includeImages = isSlash
        ? interaction.options?.getString("images") || "yes"
        : message?.content?.includes("noImages")
        ? "no"
        : "yes";
      const withImages = includeImages === "yes";

      // Send initial progress
      const progressMsg = isSlash
        ? await interaction.reply({
            content: "üïì Creating transcript... [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0%",
            fetchReply: true,
          })
        : await message.reply("üïì Creating transcript... [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0%");

      const updateProgress = async (p) => {
        const filled = Math.round(p / 10);
        const bar = "‚ñà".repeat(filled) + "‚ñë".repeat(10 - filled);
        const text = `üïì Creating transcript... [${bar}] ${p}%`;
        if (isSlash) await interaction.editReply(text);
        else await progressMsg.edit(text);
      };

      const fileName = `${channel.name.replace(/[^a-zA-Z0-9]/g, "_")}_transcript.html`;
      const filePath = path.join(__dirname, "..", "transcripts", fileName);
      await fs.ensureDir(path.dirname(filePath));

      await updateProgress(20);

      // Create transcript
      const transcript = await discordTranscripts.createTranscript(channel, {
        limit: -1,
        returnType: "buffer",
        fileName,
        saveImages: withImages,
        footerText: `Generated by ${user.tag} at ${new Date().toLocaleString()}`,
        poweredBy: false,
      });

      await fs.writeFile(filePath, transcript);
      await updateProgress(60);

      // Upload to Galactic Hosting
      const HOST = "http://us6.galactichosting.net:30028/upload";
      const form = new FormData();
      form.append("file", fs.createReadStream(filePath));

      const res = await axios.post(HOST, form, {
        headers: form.getHeaders(),
        timeout: 60000,
        maxBodyLength: Infinity,
      });

      await updateProgress(100);

      const hostedURL = res.data?.fileUrl;
      if (hostedURL) {
        const msg = `‚úÖ Transcript created!\nüìÇ [View Transcript](${hostedURL})`;
        isSlash
          ? await interaction.editReply(msg)
          : await progressMsg.edit(msg);
      } else {
        const attachment = new AttachmentBuilder(filePath, { name: fileName });
        const msg = "‚úÖ Transcript created (file attached):";
        isSlash
          ? await interaction.editReply({ content: msg, files: [attachment] })
          : await progressMsg.edit({ content: msg, files: [attachment] });
      }

      // Cleanup
      setTimeout(() => fs.unlink(filePath).catch(() => {}), 30 * 60 * 1000);
    } catch (error) {
      console.error("‚ùå TranscriptChat Error:", error);
      try {
        const errMsg = `‚ùå Failed to create transcript: ${error.message}`;
        if (interactionOrMessage?.reply) {
          await interactionOrMessage.reply(errMsg);
        } else if (interactionOrMessage?.editReply) {
          await interactionOrMessage.editReply(errMsg);
        }
      } catch (_) {}
    }
  },
};
