const { SlashCommandBuilder, AttachmentBuilder } = require("discord.js");
const discordTranscripts = require("discord-html-transcripts");
const fs = require("fs-extra");
const axios = require("axios");
const FormData = require("form-data");
const path = require("path");

module.exports = {
  name: "transcriptchat",
  description: "Generates a chat transcript (HTML format) and uploads it to SHADOW Hosting.",
  usage: "/transcriptchat [#channel] [yes|no images]",

  data: new SlashCommandBuilder()
    .setName("transcriptchat")
    .setDescription("Generate an HTML transcript of this or another channel.")
    .addChannelOption(option =>
      option.setName("channel")
        .setDescription("The channel to generate transcript from")
        .setRequired(false)
    )
    .addStringOption(option =>
      option.setName("images")
        .setDescription("Include images? (yes/no)")
        .setRequired(false)
        .addChoices(
          { name: "Yes (Include Images)", value: "yes" },
          { name: "No (No Images)", value: "no" }
        )
    ),

  async execute(interactionOrMessage, client) {
    const isSlash = !!interactionOrMessage.isChatInputCommand; // detect type
    const interaction = isSlash ? interactionOrMessage : null;
    const message = isSlash ? null : interactionOrMessage;

    try {
      const user = isSlash ? interaction.user : message.author;
      const channel = isSlash
        ? interaction.options.getChannel("channel") || interaction.channel
        : message.mentions.channels.first() || message.channel;

      const includeImages = isSlash
        ? interaction.options.getString("images") || "yes"
        : (message.content.includes("noImages") ? "no" : "yes");

      const withImages = includeImages === "yes";

      if (!channel.isTextBased()) {
        const msg = "‚ùå That channel isn‚Äôt text-based!";
        return isSlash
          ? interaction.reply({ content: msg, ephemeral: true })
          : message.reply(msg);
      }

      const progressMsg = isSlash
        ? await interaction.reply({ content: "üïì Creating transcript... [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0%", fetchReply: true })
        : await message.reply("üïì Creating transcript... [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0%");

      const fileName = `${channel.name.replace(/[^a-zA-Z0-9]/g, "_")}_transcript.html`;
      const filePath = path.join(__dirname, "..", "transcripts", fileName);
      await fs.ensureDir(path.dirname(filePath));

      const updateProgress = async (percent) => {
        const filled = Math.round((percent / 10));
        const bar = "‚ñà".repeat(filled) + "‚ñë".repeat(10 - filled);
        const text = `üïì Creating transcript... [${bar}] ${percent}%`;
        if (isSlash) await interaction.editReply(text);
        else await progressMsg.edit(text);
      };

      await updateProgress(10);

      const transcript = await discordTranscripts.createTranscript(channel, {
        limit: -1,
        returnType: "buffer",
        fileName,
        saveImages: withImages,
        footerText: `Generated by ${user.tag} on ${new Date().toLocaleString()}`,
        poweredBy: false,
      });

      await fs.writeFile(filePath, transcript);
      await updateProgress(60);

      // Upload to your hosting server
      const form = new FormData();
      form.append("file", fs.createReadStream(filePath));

      const HOST = "http://us6.galactichosting.net:30028/upload";
      const res = await axios.post(HOST, form, {
        headers: form.getHeaders(),
        timeout: 60000,
        maxBodyLength: Infinity,
        maxContentLength: Infinity,
      });

      await updateProgress(100);

      const hostedURL = res.data?.fileUrl;
      if (hostedURL) {
        const successMsg = `‚úÖ Transcript created!\nüìÇ [View Transcript](${hostedURL})`;
        isSlash
          ? await interaction.editReply(successMsg)
          : await progressMsg.edit(successMsg);
      } else {
        const attachment = new AttachmentBuilder(filePath, { name: fileName });
        const successMsg = "‚úÖ Transcript created (local file attached):";
        isSlash
          ? await interaction.editReply({ content: successMsg, files: [attachment] })
          : await progressMsg.edit({ content: successMsg, files: [attachment] });
      }

      // Cleanup local file
      setTimeout(() => fs.unlink(filePath).catch(() => {}), 60000);

    } catch (error) {
      console.error("TranscriptChat Error:", error);
      const msg = "‚ùå Failed to create transcript. Please try again later.";
      if (interactionOrMessage.reply) {
        try {
          await interactionOrMessage.reply(msg);
        } catch {
          await interactionOrMessage.followUp?.(msg);
        }
      }
    }
  },
};
